using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using BindablePropsSG.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BindablePropsSG.Generators
{
    [Generator]
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    [SuppressMessage("ReSharper", "HeapView.BoxingAllocation")]
    public class AllBindablePropsSG : BaseGenerator
    {
        private readonly HashSet<string> ignoredAttributes = new()
        {
            "IgnoredProp",
            "BindableProp",
            "IgnoredPropAttribute",
            "BindablePropAttribute",
            "AttachedProp",
            "AttachedPropAttribute",
            "BindableReadOnlyProp",
            "BindableReadOnlyPropAttribute"
        };

        protected override IEnumerable<string> TargetAttributes => new[]
        {
            "AllBindableProps",
            "AllBindablePropsAttribute"
        };

        protected override (SyntaxNode?, ISymbol?) Transform(GeneratorSyntaxContext context,
            CancellationToken cancellationToken)
        {
            var attributeSyntax = (AttributeSyntax)context.Node;

            // Attribute --> AttributeList --> Class
            if (attributeSyntax.Parent?.Parent is not ClassDeclarationSyntax classDeclarationSyntax)
                return (null, null);

            var classSymbol = context.SemanticModel
                .Compilation
                .GetTypeByMetadataName(
                    SyntaxUtil.GetClassFullname(classDeclarationSyntax)
                );

            return (classDeclarationSyntax, classSymbol);
        }

        protected override void Execute(SourceProductionContext context,
            ImmutableArray<(SyntaxNode?, ISymbol?)> classGroups)
        {
            if (classGroups.IsDefaultOrEmpty)
            {
                return;
            }

            foreach (var group in classGroups)
            {
                var (classSyntax, classSymbol) = ((ClassDeclarationSyntax?, INamedTypeSymbol?))group;
                if (classSyntax is null || classSymbol is null)
                    continue;

                var fieldTuples = classSymbol.GetMembers()
                    .Where(FieldNotIncludeAttributes)
                    .Where(item =>
                    {
                        var fieldSymbol = item as IFieldSymbol;
                        return fieldSymbol is not null && !item.IsStatic && !fieldSymbol.IsReadOnly;
                    })
                    .Select(fieldSymbol =>
                    {
                        var variableDeclaratorSyntax = SyntaxUtil.FindSyntaxBySymbol(classSyntax, fieldSymbol!);
                        return (variableDeclaratorSyntax, fieldSymbol);
                    })
                    .ToList();

                var sourceCode = ProcessClass(classSyntax, fieldTuples);
                var className = SyntaxUtil.GetClassFullname(classSyntax);

                context.AddSource($"{className}.g.cs", sourceCode);
            }
        }

        protected override string ProcessClass(TypeDeclarationSyntax? typeDeclarationSyntax,
            List<(SyntaxNode, ISymbol)> syntaxSymbols)
        {
            if (typeDeclarationSyntax is null || !syntaxSymbols.Any())
                return string.Empty;

            var usingDirectives = typeDeclarationSyntax.SyntaxTree.GetCompilationUnitRoot().Usings;

            var namespaceSyntax = typeDeclarationSyntax.Parent as BaseNamespaceDeclarationSyntax;
            var namespaceName = namespaceSyntax?.Name.ToString() ?? "global";

            var source = new StringBuilder($@"
#pragma warning disable

// <auto-generated/>
{usingDirectives}

namespace {namespaceName}
{{
    public partial class {typeDeclarationSyntax.Identifier}
    {{
");

            foreach (var (syntax, symbol) in syntaxSymbols)
            {
                // variableDeclaratorSyntax --> variableDeclarationSyntax --> fieldDeclarationSyntax
                var fieldDeclarationSyntax = syntax.Parent?.Parent!;
                ProcessField(source, typeDeclarationSyntax, fieldDeclarationSyntax, symbol);
            }

            source.Append(@"
    }
}
");

            return source.ToString();
        }

        protected override void ProcessField(StringBuilder source, TypeDeclarationSyntax typeDeclarationSyntax,
            SyntaxNode syntaxNode, ISymbol fieldSymbol)
        {
            var bindablePropParam = SyntaxUtil.ExtractCreateBindablePropertyParam(
                typeDeclarationSyntax,
                syntaxNode,
                fieldSymbol,
                "Dummy Name That I Don't Care"
            );

            source.Append($@"
        public {bindablePropParam.NewKeyWord} static readonly BindableProperty {bindablePropParam.PropName}Property = BindableProperty.Create(
                    nameof({bindablePropParam.PropName}),
                    typeof({bindablePropParam.UnNullableFieldType}),
                    typeof({bindablePropParam.ClassType}),
                    {bindablePropParam.DefaultValue},
                    propertyChanged: {bindablePropParam.PropertyChangedDelegate}
                );

        public {bindablePropParam.NewKeyWord} {bindablePropParam.FieldType} {bindablePropParam.PropName}
        {{
            get => {bindablePropParam.FieldName};
            set 
            {{ 
                OnPropertyChanging(nameof({bindablePropParam.PropName}));

                {bindablePropParam.FieldName} = value;
                SetValue({bindablePropParam.ClassType}.{bindablePropParam.PropName}Property, {bindablePropParam.FieldName});

                OnPropertyChanged(nameof({bindablePropParam.PropName}));
            }}
        }}
");
        }

        private bool FieldNotIncludeAttributes(ISymbol symbol)
        {
            if (symbol is IFieldSymbol fieldSymbol)
            {
                return fieldSymbol.GetAttributes().Any(
                    attribute =>
                    {
                        var name = attribute?.AttributeClass?.Name;
                        return ignoredAttributes.Contains(name!);
                    }
                ) is not true;
            }

            return false;
        }
    }
}