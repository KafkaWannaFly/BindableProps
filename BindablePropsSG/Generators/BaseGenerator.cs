using System.Collections.Immutable;
using System.Text;
using BindablePropsSG.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BindablePropsSG.Generators;

[Generator]
public class BaseGenerator : IIncrementalGenerator
{
    public virtual void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var syntaxSymbols = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: Predicate,
                transform: Transform
            )
            .Where(item => item is not (null, null))
            .Collect();

        context.RegisterSourceOutput(syntaxSymbols, Execute);
    }

    protected virtual IEnumerable<string> TargetAttributes => [];

    protected virtual bool Predicate(SyntaxNode node, CancellationToken cancellationToken)
    {
        if (node is not AttributeSyntax attributeSyntax)
        {
            return false;
        }

        var name = SyntaxUtil.ExtractName(attributeSyntax.Name);

        return name != null && TargetAttributes.Contains(name);
    }

    protected virtual (SyntaxNode?, ISymbol?) Transform(GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        // Attribute --> AttributeList --> Field
        if (attributeSyntax.Parent?.Parent is not FieldDeclarationSyntax syntax)
            return default;

        var symbol =
            context.SemanticModel.GetDeclaredSymbol(syntax.Declaration.Variables.FirstOrDefault()!);

        return (syntax, symbol);
    }

    protected virtual void Execute(SourceProductionContext context,
        ImmutableArray<(SyntaxNode?, ISymbol?)> syntaxSymbols)
    {
        if (syntaxSymbols.IsDefaultOrEmpty)
            return;

        var groupList = syntaxSymbols.GroupBy<(SyntaxNode, ISymbol), TypeDeclarationSyntax>(
            fieldGroup => (TypeDeclarationSyntax)fieldGroup.Item1!.Parent!
        );

        foreach (var group in groupList)
        {
            var sourceCode = ProcessClass(group.Key, group.ToList()).Trim();
            var className = SyntaxUtil.GetClassFullname(group.Key);

            context.AddSource($"{className}.g.cs", sourceCode);
        }
    }

    protected virtual string ProcessClass(TypeDeclarationSyntax? typeDeclarationSyntax,
        List<(SyntaxNode, ISymbol)> syntaxSymbols)
    {
        if (typeDeclarationSyntax is null)
        {
            return string.Empty;
        }

        var excludedUsings = typeDeclarationSyntax.SyntaxTree.GetCompilationUnitRoot().Members.ToString();
        var allCode = typeDeclarationSyntax.SyntaxTree.ToString();
        var usingDirectives = allCode.Replace(excludedUsings, string.Empty);

        var namespaceSyntax = typeDeclarationSyntax.Parent as BaseNamespaceDeclarationSyntax;
        var namespaceName = namespaceSyntax?.Name.ToString() ?? "global";

        var accessLevelKeyWords = typeDeclarationSyntax.Modifiers
            .Where(
                modifier => modifier.IsKind(SyntaxKind.PrivateKeyword)
                            || modifier.IsKind(SyntaxKind.PublicKeyword)
                            || modifier.IsKind(SyntaxKind.InternalKeyword)
                            || modifier.IsKind(SyntaxKind.ProtectedKeyword)
            )
            .Select(modifier => modifier.Text);
        var accessLevel = string.Join(" ", accessLevelKeyWords);


        var source = new StringBuilder($$"""

                                         #pragma warning disable

                                         // <auto-generated/>
                                         {{usingDirectives}}

                                         namespace {{namespaceName}}
                                         {
                                             {{accessLevel}} partial {{typeDeclarationSyntax.Keyword.Text}} {{typeDeclarationSyntax.Identifier}}
                                             {

                                         """);

        foreach (var (syntax, symbol) in syntaxSymbols)
        {
            ProcessField(source, typeDeclarationSyntax, syntax, symbol);
        }

        source.Append("""

                          }
                      }

                      """);

        return source.ToString();
    }

    protected virtual string ProcessClass((SyntaxNode, ISymbol) group)
    {
        return string.Empty;
    }

    protected virtual void ProcessField(StringBuilder source, TypeDeclarationSyntax typeDeclarationSyntax,
        SyntaxNode fieldSyntax, ISymbol fieldSymbol)
    {
    }
}