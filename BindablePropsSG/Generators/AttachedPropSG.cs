using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Text;
using BindablePropsSG.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace BindablePropsSG.Generators;

[Generator]
[SuppressMessage("ReSharper", "InconsistentNaming")]
[SuppressMessage("ReSharper", "HeapView.BoxingAllocation")]
public class AttachedPropSG : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        var fieldGroups = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: IsAttachedProp,
                transform: Transform
            )
            .Where(item => item is not (null, null))
            .Collect();

        context.RegisterSourceOutput(fieldGroups, Execute);
    }

    private void Execute(SourceProductionContext context,
        ImmutableArray<(FieldDeclarationSyntax?, IFieldSymbol?)> fieldSyntaxesAndSymbols)
    {
        if (fieldSyntaxesAndSymbols.IsDefaultOrEmpty)
            return;

        var groupList = fieldSyntaxesAndSymbols.GroupBy<(FieldDeclarationSyntax, IFieldSymbol), ClassDeclarationSyntax>(
            fieldGroup => (ClassDeclarationSyntax)fieldGroup.Item1!.Parent!
        );

        foreach (var group in groupList)
        {
            var sourceCode = ProcessClass(group.Key, group.ToList());
            var className = SyntaxUtil.GetClassFullname(group.Key);

            context.AddSource($"{className}.g.cs", sourceCode);
        }
    }

    private string ProcessClass(ClassDeclarationSyntax? classSyntax,
        List<(FieldDeclarationSyntax, IFieldSymbol)> fieldGroup)
    {
        if (classSyntax is null)
        {
            return string.Empty;
        }

        var usingDirectives = classSyntax.SyntaxTree.GetCompilationUnitRoot().Usings;

        var namespaceSyntax = classSyntax.Parent as BaseNamespaceDeclarationSyntax;
        var namespaceName = namespaceSyntax?.Name.ToString() ?? "global";

        var source = new StringBuilder($@"
// <auto-generated/>
{usingDirectives}

namespace {namespaceName}
{{
    public partial class {classSyntax.Identifier}
    {{
");

        foreach (var (fieldSynTax, fieldSymbol) in fieldGroup)
        {
            ProcessField(source, classSyntax, fieldSynTax, fieldSymbol);
        }

        source.Append(@$"
    }}
}}
");

        return source.ToString();
    }

    private void ProcessField(StringBuilder source, ClassDeclarationSyntax classSyntax,
        FieldDeclarationSyntax fieldSyntax, IFieldSymbol fieldSymbol)
    {
        var fieldName = fieldSymbol.Name;
        var pascalCaseFieldName = StringUtil.PascalCaseOf(fieldName);
        var propName = $"{pascalCaseFieldName}Property";

        if (pascalCaseFieldName.Length == 0 || pascalCaseFieldName == fieldName)
        {
            return;
        }

        var fieldType = fieldSyntax.Declaration.Type;

        var className = classSyntax.Identifier;

        var defaultFieldValue = SyntaxUtil.GetFieldDefaultValue(fieldSyntax) ?? "default";

        var attributeSyntax = SyntaxUtil.GetAttributeByName(fieldSyntax, "AttachedProp");

        var attributeArguments = attributeSyntax?.ArgumentList?.Arguments;

        var defaultBindingMode = SyntaxUtil.GetAttributeParam(attributeArguments, "DefaultBindingMode") ?? "0";

        var validateValueDelegate = SyntaxUtil.GetAttributeParam(attributeArguments, "ValidateValueDelegate") ?? "null";

        var propertyChangedDelegate = SyntaxUtil.GetAttributeParam(
            attributeArguments, "PropertyChangedDelegate"
        ) ?? @$"(bindable, oldValue, newValue) => 
                        (({className})bindable).{pascalCaseFieldName} = ({fieldType})newValue";

        var propertyChangingDelegate =
            SyntaxUtil.GetAttributeParam(attributeArguments, "PropertyChangingDelegate") ?? "null";

        var coerceValueDelegate = SyntaxUtil.GetAttributeParam(attributeArguments, "CoerceValueDelegate") ?? "null";

        var createDefaultValueDelegate =
            SyntaxUtil.GetAttributeParam(attributeArguments, "CreateDefaultValueDelegate") ?? "null";

        source.Append($@"
        public static readonly BindableProperty {propName} = BindableProperty.CreateAttached(
            ""{pascalCaseFieldName}"",
            typeof({fieldType}),
            typeof({className}),
            {defaultFieldValue},
            (BindingMode){defaultBindingMode},
            {validateValueDelegate},
            {propertyChangedDelegate},
            {propertyChangingDelegate},
            {coerceValueDelegate},
            {createDefaultValueDelegate}
        );

        public static {fieldType} Get{pascalCaseFieldName}(BindableObject view)
        {{
            return ({fieldType})view.GetValue({propName});
        }}

        public static void Set{pascalCaseFieldName}(BindableObject view, {fieldType} value)
        {{
            view.SetValue({propName}, value);
        }}
        
");
    }

    private (FieldDeclarationSyntax?, IFieldSymbol?) Transform(GeneratorSyntaxContext context,
        CancellationToken cancellationToken)
    {
        var attributeSyntax = (AttributeSyntax)context.Node;

        // Attribute --> AttributeList --> Field
        if (attributeSyntax.Parent?.Parent is not FieldDeclarationSyntax fieldSyntax)
            return (null, null);

        var fieldSymbol =
            context.SemanticModel.GetDeclaredSymbol(fieldSyntax.Declaration.Variables
                .FirstOrDefault()!) as IFieldSymbol;

        return (fieldSyntax, fieldSymbol);
    }

    private bool IsAttachedProp(SyntaxNode syntaxNode, CancellationToken _)
    {
        if (syntaxNode is not AttributeSyntax attributeSyntax)
        {
            return false;
        }

        var name = SyntaxUtil.ExtractName(attributeSyntax.Name);

        return name is "AttachedProp" or "AttachedPropAttribute";
    }
}