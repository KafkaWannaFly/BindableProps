using BindablePropsSG.Utils;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using System.Collections.Immutable;
using System.Diagnostics.CodeAnalysis;
using System.Text;

namespace BindablePropsSG.Generators
{
    [Generator]
    [SuppressMessage("ReSharper", "InconsistentNaming")]
    [SuppressMessage("ReSharper", "HeapView.BoxingAllocation")]
    public class BindablePropSG : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {

            var fieldGroups = context.SyntaxProvider
                .CreateSyntaxProvider(
                    predicate: IsBindableProp,
                    transform: Transform
                )
                .Where(item => item is not (null, null))
                .Collect();

            context.RegisterSourceOutput(fieldGroups, Execute);
        }

        private bool IsBindableProp(SyntaxNode node, CancellationToken _)
        {
            if (node is not AttributeSyntax attributeSyntax)
            {
                return false;
            }

            var name = SyntaxUtil.ExtractName(attributeSyntax.Name);

            return name is "BindableProp" or "BindablePropAttribute";
        }

        private (FieldDeclarationSyntax?, IFieldSymbol?) Transform(GeneratorSyntaxContext context, CancellationToken cancellationToken)
        {
            var attributeSyntax = (AttributeSyntax)context.Node;

            // Attribute --> AttributeList --> Field
            if (attributeSyntax.Parent?.Parent is not FieldDeclarationSyntax fieldSyntax)
                return (null, null);

            var fieldSymbol = context.SemanticModel.GetDeclaredSymbol(fieldSyntax.Declaration.Variables.FirstOrDefault()!) as IFieldSymbol;

            return (fieldSyntax, fieldSymbol);
        }

        private void Execute(SourceProductionContext context, ImmutableArray<(FieldDeclarationSyntax?, IFieldSymbol?)> fieldSyntaxesAndSymbols)
        {
            if (fieldSyntaxesAndSymbols.IsDefaultOrEmpty)
                return;

            var groupList = fieldSyntaxesAndSymbols.GroupBy<(FieldDeclarationSyntax, IFieldSymbol), ClassDeclarationSyntax>(
                    fieldGroup => (ClassDeclarationSyntax)fieldGroup.Item1!.Parent!
                );

            foreach (var group in groupList)
            {
                var sourceCode = ProcessClass(group.Key, group.ToList());
                var className = SyntaxUtil.GetClassFullname(group.Key);

                context.AddSource($"{className}.g.cs", sourceCode);
            }
        }

        private string ProcessClass(ClassDeclarationSyntax? classSyntax, List<(FieldDeclarationSyntax, IFieldSymbol)> fieldGroup)
        {
            if (classSyntax is null)
            {
                return string.Empty;
            }

            var usingDirectives = classSyntax.SyntaxTree.GetCompilationUnitRoot().Usings;

            var namespaceSyntax = classSyntax.Parent as BaseNamespaceDeclarationSyntax;
            var namespaceName = namespaceSyntax?.Name.ToString() ?? "global";

            var source = new StringBuilder($@"
// <auto-generated/>
{usingDirectives}

namespace {namespaceName}
{{
    public partial class {classSyntax.Identifier}
    {{
");

            // create properties for each field 
            foreach (var (fieldSynTax, fieldSymbol) in fieldGroup)
            {
                ProcessField(source, classSyntax, fieldSynTax, fieldSymbol);
            }

            source.Append(@$"
    }}
}}
");
            return source.ToString();
        }

        private void ProcessField(StringBuilder source, ClassDeclarationSyntax classSyntax, FieldDeclarationSyntax fieldSyntax, IFieldSymbol fieldSymbol)
        {
            var fieldName = fieldSymbol.Name;
            var propName = StringUtil.PascalCaseOf(fieldName);

            if (propName.Length == 0 || propName == fieldName)
            {
                return;
            }

            var fieldType = fieldSyntax.Declaration.Type;

            var className = classSyntax.Identifier;

            var defaultFieldValue = SyntaxUtil.GetFieldDefaultValue(fieldSyntax) ?? "default";

            var attributeSyntax = SyntaxUtil.GetAttributeByName(fieldSyntax, "BindableProp");

            var attributeArguments = attributeSyntax?.ArgumentList?.Arguments;

            var defaultBindingMode = SyntaxUtil.GetAttributeParam(attributeArguments, "DefaultBindingMode") ?? "0";

            var validateValueDelegate = SyntaxUtil.GetAttributeParam(attributeArguments, "ValidateValueDelegate") ?? "null";

            var propertyChangedDelegate = SyntaxUtil.GetAttributeParam(
                attributeArguments, "PropertyChangedDelegate"
                ) ?? @$"(bindable, oldValue, newValue) => 
                        (({className})bindable).{propName} = ({fieldType})newValue";

            var propertyChangingDelegate = SyntaxUtil.GetAttributeParam(attributeArguments, "PropertyChangingDelegate") ?? "null";

            var coerceValueDelegate = SyntaxUtil.GetAttributeParam(attributeArguments, "CoerceValueDelegate") ?? "null";

            var createDefaultValueDelegate = SyntaxUtil.GetAttributeParam(attributeArguments, "CreateDefaultValueDelegate") ?? "null";

            source.Append($@"
        public static readonly BindableProperty {propName}Property = BindableProperty.Create(
            nameof({propName}),
            typeof({fieldType}),
            typeof({className}),
            {defaultFieldValue},
            (BindingMode){defaultBindingMode},
            {validateValueDelegate},
            {propertyChangedDelegate},
            {propertyChangingDelegate},
            {coerceValueDelegate},
            {createDefaultValueDelegate}
        );

        public {fieldType} {propName}
        {{
            get => {fieldName};
            set 
            {{ 
                OnPropertyChanging(nameof({propName}));

                {fieldName} = value;
                SetValue({className}.{propName}Property, {fieldName});

                OnPropertyChanged(nameof({propName}));
            }}
        }}
");
        }
    }
}
